use std::sync::Arc;

use {BoxedErr, Source, SourceId};

/// One of the three core traits of this crate.
///
/// You want to implement this for every type of asset like
///
/// * `Mesh`
/// * `Texture`
/// * `Terrain`
///
/// and so on. Now, an asset may be available in different formats.
/// That's why we have the `Data` associated type here. You can specify
/// an intermediate format here, like the vertex data for a mesh or the samples
/// for audio data.
///
/// This data is then generated by the `Format` trait.
pub trait Asset: Send + Sync + 'static {
    /// The `Data` type the asset can be created from.
    type Data: Send + Sync + 'static;
}

/// A specifier for an asset, uniquely identifying it by
///
/// * the extension (the format it was provided in)
/// * its name
/// * the storage it was loaded from
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AssetSpec {
    /// The possible extensions of this asset
    pub exts: &'static [&'static str],
    /// The name of this asset.
    pub name: String,
    /// Unique identifier indicating the Storage from which the asset was loaded.
    pub store: SourceId,
}

impl AssetSpec {
    /// Creates a new asset specifier from the given parameters.
    pub fn new(name: String, exts: &'static [&'static str], store: SourceId) -> Self {
        AssetSpec { exts, name, store }
    }
}

/// A format, providing a conversion from bytes to asset data, which is then
/// in turn accepted by `Asset::from_data`. Examples for formats are
/// `Png`, `Obj` and `Wave`.
pub trait Format<A: Asset>: Send + 'static {
    /// A unique identifier for this format.
    const NAME: &'static str;

    /// Reads the given bytes and produces asset data.
    fn import(&self, name: String, source: Arc<Source>) -> Result<A::Data, BoxedErr>;
}
